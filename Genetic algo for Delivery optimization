import random
import numpy as np
import matplotlib.pyplot as plt

# Sample delivery locations (x, y coordinates)
locations = [
    (0, 0), (2, 3), (5, 4), (1, 6), (7, 8),
    (6, 1), (3, 7), (8, 3), (9, 9), (4, 5)
]

# Calculate distance matrix
def euclidean_distance(p1, p2):
    return np.linalg.norm(np.array(p1) - np.array(p2))

distance_matrix = [[euclidean_distance(i, j) for j in locations] for i in locations]

# GA parameters
POP_SIZE = 100
ELITE_SIZE = 20
MUTATION_RATE = 0.01
GENERATIONS = 500

# Route fitness
def route_distance(route):
    return sum(distance_matrix[route[i]][route[i + 1]] for i in range(len(route) - 1)) + distance_matrix[route[-1]][route[0]]

def fitness(route):
    return 1 / route_distance(route)

# Initial population
def initial_population(size, city_count):
    return [random.sample(range(city_count), city_count) for _ in range(size)]

# Selection
def selection(population, fitnesses):
    selected = []
    for _ in range(ELITE_SIZE):
        idx = np.argmax(fitnesses)
        selected.append(population[idx])
        fitnesses[idx] = -9999  # Exclude for next selection
    return selected

# Ordered crossover
def crossover(parent1, parent2):
    start, end = sorted(random.sample(range(len(parent1)), 2))
    child = [None] * len(parent1)
    child[start:end] = parent1[start:end]
    fill = [item for item in parent2 if item not in child]
    pointer = 0
    for i in range(len(child)):
        if child[i] is None:
            child[i] = fill[pointer]
            pointer += 1
    return child

# Mutation (swap)
def mutate(route):
    for i in range(len(route)):
        if random.random() < MUTATION_RATE:
            j = random.randint(0, len(route) - 1)
            route[i], route[j] = route[j], route[i]
    return route

# Next generation
def next_generation(current_gen):
    fitnesses = [fitness(ind) for ind in current_gen]
    elites = selection(current_gen.copy(), fitnesses.copy())
    children = elites.copy()

    while len(children) < POP_SIZE:
        p1, p2 = random.sample(elites, 2)
        child = mutate(crossover(p1, p2))
        children.append(child)

    return children

# GA main loop
def genetic_algorithm():
    population = initial_population(POP_SIZE, len(locations))
    best_route = None
    best_distance = float('inf')

    for gen in range(GENERATIONS):
        population = next_generation(population)
        current_best = min(population, key=route_distance)
        current_distance = route_distance(current_best)

        if current_distance < best_distance:
            best_distance = current_distance
            best_route = current_best

        if gen % 50 == 0:
            print(f"Gen {gen} - Best Distance: {best_distance:.2f}")

    return best_route, best_distance

# Plotting the best route
def plot_route(route):
    route_points = [locations[i] for i in route] + [locations[route[0]]]
    x, y = zip(*route_points)
    plt.figure(figsize=(10, 6))
    plt.plot(x, y, 'o-')
    plt.title('Optimized Delivery Route')
    for idx, point in enumerate(route_points):
        plt.text(point[0], point[1], str(idx % len(locations)))
    plt.grid()
    plt.show()

# Run GA
best_route, best_distance = genetic_algorithm()
print("Best Route:", best_route)
print("Total Distance:", best_distance)
plot_route(best_route)
